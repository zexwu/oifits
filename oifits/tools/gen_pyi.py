#!/usr/bin/env python3
from __future__ import annotations

import importlib
import inspect
import os
import pkgutil
import re
import sys
from pathlib import Path
from typing import Any, Iterable


def _find_package_dir(script_path: Path) -> Path:
    """
    Assume this script is either:
      - inside <pkg>/ (same dir as __init__.py), or
      - inside <pkg>/tools/ (or any subdir)
    We walk upwards until we find a directory containing __init__.py and base.py.
    """
    p = script_path.resolve()
    for parent in [p.parent] + list(p.parents):
        if (parent / "__init__.py").exists() and (parent / "base.py").exists():
            return parent
    raise RuntimeError("Cannot locate package directory (needs __init__.py and base.py).")


def _iter_submodules(pkg_name: str) -> Iterable[str]:
    pkg = importlib.import_module(pkg_name)
    if not hasattr(pkg, "__path__"):
        return
    for m in pkgutil.walk_packages(pkg.__path__, pkg.__name__ + "."):
        yield m.name


def _read_init_exports(init_py: Path) -> tuple[list[str], dict[str, str], dict[str, int]]:
    """
    Parse __init__.py to capture:
      - exported class names (from .module import NAME)
      - name -> module mapping for those exports
      - integer constants (e.g. GRAVITY_FT = 20)
    """
    text = init_py.read_text(encoding="utf-8")

    # from .oi_vis import OI_VIS
    import_re = re.compile(r"^\s*from\s+\.(\w+)\s+import\s+(\w+)\s*$", re.M)
    exports: list[str] = []
    export_mod: dict[str, str] = {}
    for mod, name in import_re.findall(text):
        exports.append(name)
        export_mod[name] = mod

    # GRAVITY_FT = 20
    const_re = re.compile(r"^\s*([A-Z][A-Z0-9_]*)\s*=\s*(\d+)\s*$", re.M)
    consts: dict[str, int] = {k: int(v) for k, v in const_re.findall(text)}

    return exports, export_mod, consts


def _py_attr_from_col(col: str) -> str:
    # your runtime rule in HDUModel: attr = colname.lower()
    return col.lower()


def main() -> None:
    script_path = Path(__file__)
    pkg_dir = _find_package_dir(script_path)
    pkg_name = pkg_dir.name

    # Ensure parent of package is on sys.path for import
    sys.path.insert(0, str(pkg_dir.parent))

    # Import package + all submodules so subclasses are registered
    importlib.import_module(pkg_name)
    for mod in _iter_submodules(pkg_name):
        importlib.import_module(mod)

    base_mod = importlib.import_module(f"{pkg_name}.base")
    HDUModel = getattr(base_mod, "HDUModel")

    # Collect subclasses (direct + indirect)
    def all_subclasses(cls) -> set[type]:
        out: set[type] = set()
        for sub in cls.__subclasses__():
            out.add(sub)
            out |= all_subclasses(sub)
        return out

    subclasses = sorted(all_subclasses(HDUModel), key=lambda c: c.__name__)

    # Parse __init__.py exports/constants so stub matches public API
    exports, export_mod, consts = _read_init_exports(pkg_dir / "__init__.py")

    out_lines: list[str] = []
    out_lines.append("from __future__ import annotations")
    out_lines.append("")
    out_lines.append("from typing import Any, ClassVar, Optional, Sequence, Tuple, Iterable")
    out_lines.append("import numpy as np")
    out_lines.append("from numpy.typing import NDArray")
    out_lines.append("from astropy.io import fits")
    out_lines.append("")
    out_lines.append("# Auto-generated by gen_pyi.py. DO NOT EDIT BY HAND.")
    out_lines.append("")

    # Re-exported names (keep same surface API)
    # This helps "from <pkg> import OI_VIS" etc.
    if exports and False:
        out_lines.append("# Public re-exports (from __init__.py)")
        for name in exports:
            mod = export_mod.get(name)
            if mod:
                out_lines.append(f"from .{mod} import {name} as {name}")
        out_lines.append("")

    # Constants
    if consts:
        out_lines.append("# Constants (from __init__.py)")
        for k in sorted(consts.keys()):
            out_lines.append(f"{k}: int")
        out_lines.append("")

    # Base class stub
    out_lines.append("class HDUModel:")
    out_lines.append("    EXTNAME: ClassVar[str]")
    out_lines.append("    COLUMNS: ClassVar[Sequence[Tuple[str, bool]]]")
    out_lines.append("    header: dict[str, Any]")
    out_lines.append("    extver: Optional[int]")
    out_lines.append("    insname: Optional[str]")
    out_lines.append("    arrname: Optional[str]")
    out_lines.append("    def __init__(")
    out_lines.append("        self,")
    out_lines.append("        hdul: fits.HDUList,")
    out_lines.append("        extver: Optional[int] = ...,")
    out_lines.append("        header_keys: Optional[list[str]] = ...,")
    out_lines.append("    ) -> None: ...")
    out_lines.append("    def _post_decode(self) -> None: ...")
    out_lines.append("    def __repr__(self) -> str: ...")
    out_lines.append("")

    # Subclass stubs generated from COLUMNS
    out_lines.append("# HDUModel subclasses (generated from COLUMNS)")
    for cls in subclasses:
        name = cls.__name__
        cols = getattr(cls, "COLUMNS", ())
        out_lines.append(f"class {name}(HDUModel):")
        out_lines.append("    EXTNAME: ClassVar[str]")
        out_lines.append("    COLUMNS: ClassVar[Sequence[Tuple[str, bool]]]")
        # generate attrs
        for colname, required in cols:
            attr = _py_attr_from_col(colname)
            if required:
                out_lines.append(f"    {attr}: NDArray[Any]")
            else:
                out_lines.append(f"    {attr}: Optional[NDArray[Any]]")
        out_lines.append("")

    # If there is an OI dataclass, stub it explicitly (matches your oi.py)
    try:
        oi_mod = importlib.import_module(f"{pkg_name}.oi")
        OI = getattr(oi_mod, "OI", None)
        if inspect.isclass(OI):
            out_lines.append("# OI aggregate container")
            out_lines.append("class OI:")
            out_lines.append("    array: OI_ARRAY")
            out_lines.append("    wavelength: OI_WAVELENGTH")
            out_lines.append("    flux: OI_FLUX")
            out_lines.append("    vis: OI_VIS")
            out_lines.append("    t3: OI_T3")
            # keep signature consistent with your current code (extver is passed through)
            out_lines.append("    extver: Any")
            out_lines.append("    @classmethod")
            out_lines.append("    def load(cls, hdul: fits.HDUList, extver: Any = ...) -> OI: ...")
            out_lines.append("")
    except Exception:
        # If oi.py doesn't exist or import fails, just skip
        pass

    stub_path = pkg_dir / "__init__.pyi"
    stub_path.write_text("\n".join(out_lines) + "\n", encoding="utf-8")
    print(f"Wrote: {stub_path}")


if __name__ == "__main__":
    main()
